# 练习

对实验报告的要求：
 - 基于markdown格式来完成，以文本方式为主
 - 填写各个基本练习中要求完成的报告内容
 - 完成实验后，请分析ucore_lab中提供的参考答案，并请在实验报告中说明你的实现与参考答案的区别
 - 列出你认为本实验中重要的知识点，以及与对应的OS原理中的知识点，并简要说明你对二者的含义，关系，差异等方面的理解（也可能出现实验中的知识点没有对应的原理知识点）
 - 列出你认为OS原理中很重要，但在实验中没有对应上的知识点

## 练习0：填写已有实验

本实验依赖实验1。请把你做的实验1的代码填入本实验中代码中有“LAB1”的注释相应部分并按照实验手册进行进一步的修改。具体来说，就是跟着实验手册的教程一步步做，然后完成教程后继续完成完成exercise部分的剩余练习。

## 练习1：理解first-fit 连续物理内存分配算法（思考题）
first-fit 连续物理内存分配算法作为物理内存分配一个很基础的方法，需要同学们理解它的实现过程。请大家仔细阅读实验手册的教程并结合`kern/mm/default_pmm.c`中的相关代码，认真分析default_init，default_init_memmap，default_alloc_pages， default_free_pages等相关函数，并描述程序在进行物理内存分配的过程以及各个函数的作用。
请在实验报告中简要说明你的设计实现过程。请回答如下问题：
- 你的first fit算法是否有进一步的改进空间？

### First-fit
##### init
算法的最开始，我们需要初始化一个双向循环链表，其实就是给这个链表一个表头(`free_list`)，用来准备管理我们的物理空闲块。在`default_init`函数中完成这个操作，其功能非常简单，就是让这个表头的两个指针都指向自己。这个表头的首元素`nr_free`记录了空闲页的数量。

##### init_memmap
###### page_init
在空闲链表的初始化之后，就应该来探测我们拥有的物理内存空间，然后将其通过该链表管理起来。

我们有多少物理空间可用呢？在本次实验中，其实是写死的，DRAM的空间就是从0x8000 0000到0x8800 0000的128MiB空间。考虑到其中的OpenSBI占用了0x8000 0000到0x8020 0000的空间，而kernel占用了0x8020 0000到end(在链接脚本中定义)的空间，也就是说，实际上我们能用来存东西的空间是从end到0x8800 0000。

那么剩下的空间能够全部当作用户可用的页来使用吗？当然不行，至少我们需要一些额外的信息，例如页状态的标志位、空闲链表的入口点等其它属性也需要存储在这片空间。这些属性存在哪儿呢？每个页的开头吗？如果是这样的话，存储真正用户数据的空间就不再是4KiB，那么用户的对齐操作就不再可控，这时候很可能会降低效率。于是，把页的信息单独摘出来存，是个不错的选择。这就是`page_init`开头干的事情。

具体来说`page_init`分配了0x8000(0x88000 -0x80000)个`page`结构体，一个`page`对应了DRAM中的一个页(即4KiB空间)，由于它是连续分布的，内存地址也是连续分布的，因此可以通过一个简单的映射`page2pa`得到对应页的实际物理地址，反过来也可以由`pa2page`得到对应的`page`结构体，因此虽然这个"page"和想象中的页不一样，但这样命名并没有错。

接着，将我们存有`page`的空间置为保留，这部分不能给用户使用。然后对于剩下的空间，我们进行`init_memmap`。
###### init_memmap
在函数`default_init_memmap`中，由于现在整个空闲内存都没有被使用，因此，这算作是一大个空闲块。根据first fit算法的思想，只需要将第一个`page`作为“代表大哥”链入`free_list`即可。为了体现“代表大哥”的身份，在第一个page的property属性被置为它管理小弟的数量n，而其它的page的property属性均为0。

怎么体现页面空闲还是占用呢？并不是看`free_list`，`free_list`只是方便分配空闲块而已，真正要看的是每个page的flag属性，所以每次进入`free_list`的块中的所有页，要把flag置位(`SETPROPERTY`)，反之，则需要清位(`CLEARPROPERTY`)。因此在init里面不能忘记置位。

#### 分配与回收
##### default_alloc_pages
一个空闲块，如何算是被分配出去了？
1. 首先，根据上述的思想，块中的每一个page的flag位应该都要置位；
2. 其次，`free_list`中的“代表大哥”应该“带队出链”，而剩下的队伍需要一个新的“代表大哥”管理。
3. 然后，需要给出空闲块的物理地址以及大小(页数量)，以供使用，这在外部通过调用`page2pa`可以实现；而这里的分配算法返回一个`page`的指针就行。那么只拿到一个page，如何访问该块中的其它page呢？很简单，这些page本身就是连续分布的，相当于用数组下标访问就行。
当然，还有一些检查的细节啥的，就不赘述了。

##### default_free_pages
似乎按照上述的逻辑就算一直分配空闲块，`free_list`中永远只有一个块，这个链表好像多此一举似的。而且一直分配的话空间一直都是连续的，first fit也没有造成空间的浪费。

但页面分配不可能只借不还的，那么和上面类似的问题，一个页面如何算是回收了呢？
1. 同样，是flag清位；
2. 然后，是大哥归位；这部分很讲究，当某块空闲块不用的时候，还是选举其第一个页作为大哥，带队回到`free_list`，这时候`free_list`就有多个空闲块了，而且大小可能不一。如果它们不连续，那么两个大哥各自带自己的队伍，井水不犯河水。
3. 如果两者连续呢？这时候就不能任由它们我行我素了，需要进行合并。如果不合并，空闲内存中的地址看似是连续的，但实际却是坑坑洼洼的，如果每次回来的块都不合并，那么可以想见，后续的块大小会越来越小，导致无法支持较大的分配要求。
4. 如何合并呢？代码中的实现就是在链表中向前看看前面(`prev`)那一块是不是空闲的，如果是，那么新加入的块和前面那块合并；接着，再往后(`next`)看看，合并后的新块跟后面的空闲块是不是还连续，如果是，就再合并在一起。
5. 最后提一嘴page的ref为应该要置为0，但是引用计数应该不是该算法用到的，因此主要是记住，别忘记就行。
#### 关于优化的思考
##### 关于空间的优化
first fit算法最大的弊端就是在一系列反复的“分配-释放”之后，内存空间会变得零碎(即使有合并)。如何解决这个问题呢？
我考虑过“内存紧凑”的方法，就是每隔一段时间，把不连续的内存重新分配一下；但显然这样的弊端也很明显，先不谈按怎样的方式才能排得紧凑，但是内存的I/O就开销巨大，究竟合不合算，没有实际经验的我也不清楚。
其次就是考虑“动态分配”的方式，就是检查局部内存利用率，然后对于利用率低的部分，将空闲的块进行强制合并。这样思路挺好的，但实现起来挺难的，前面提到分配的块里面的页是连续的，因此可以通过下标访问。如果想要将分隔开的页面连接起来的话，还需要一个链表将不同区域的块链接起来，这倒不是什么难题，难就难在回收的时候，我完全梳理不清楚当归还这个“东拼西凑”的空间的时候，究竟得检查多少事情！
有一句话说得好：“如果空间零碎的问题解决了，它还是first fit算法吗？”或许这个角度确实没法做到吧。

另外，关于空间，也许flag可以用更小的存储类型？但是flag还有没有其它用途？目前不清楚，而且修改之后究竟有没有提升？也不清楚。(毕竟4KiB对齐，就算优化也可能优化不了多少空间)
##### 关于时间的优化
###### 缓存
GPT给的思路，反正空间换时间吧，但我感觉仅仅是页面的置位、链表操作啥的，还不至于用这玩意儿

###### 时间复杂度
关于这点，网上看到一些说法。大致思路是让最后一页也记录property的信息，由此一个空闲块回收的时候，可以直接检查相邻的两页，然后看它们是不是空闲，如果是就依据property找到前面一个块的带头大哥，然后再拿到后面一个块的带头大哥(其实就是后面一页)，直接合并就好。这样原本线性复杂度(`O(size(free_list))`)，就降为了常数级别。

关于这个问题，我觉得虽然这确实属于一种优化，但我不懂其中的优化力度怎样，值不值得每次做这些额外的检查操作。因为两端都连续的回收情况究竟多见还是少见，我不知道；而且这个`free_list`的长度究竟会不会太长？(我还去看了ucore-x86的代码，发现这部分是每一页都连进去的，但是我们的实验中的代码每块只是链入一个页，因此这部分已经优化过了。)不太说得清楚，也许细节决定成败吧。

## 练习2：实现 Best-Fit 连续物理内存分配算法（需要编程）
在完成练习一后，参考kern/mm/default_pmm.c对First Fit算法的实现，编程实现Best Fit页面分配算法，算法的时空复杂度不做要求，能通过测试即可。
请在实验报告中简要说明你的设计实现过程，阐述代码是如何对物理内存进行分配和释放，并回答如下问题：
- 你的 Best-Fit 算法是否有进一步的改进空间？

## 扩展练习Challenge：buddy system（伙伴系统）分配算法（需要编程）

Buddy System算法把系统中的可用存储空间划分为存储块(Block)来进行管理, 每个存储块的大小必须是2的n次幂(Pow(2, n)), 即1, 2, 4, 8, 16, 32, 64, 128...

 -  参考[伙伴分配器的一个极简实现](http://coolshell.cn/articles/10427.html)， 在ucore中实现buddy system分配算法，要求有比较充分的测试用例说明实现的正确性，需要有设计文档。
 
## 扩展练习Challenge：任意大小的内存单元slub分配算法（需要编程）

slub算法，实现两层架构的高效内存单元分配，第一层是基于页大小的内存分配，第二层是在第一层基础上实现基于任意大小的内存分配。可简化实现，能够体现其主体思想即可。

 - 参考[linux的slub分配算法/](http://www.ibm.com/developerworks/cn/linux/l-cn-slub/)，在ucore中实现slub分配算法。要求有比较充分的测试用例说明实现的正确性，需要有设计文档。

## 扩展练习Challenge：硬件的可用物理内存范围的获取方法（思考题）
  - 如果 OS 无法提前知道当前硬件的可用物理内存范围，请问你有何办法让 OS 获取可用物理内存范围？


> Challenges是选做，完成Challenge的同学可单独提交Challenge。完成得好的同学可获得最终考试成绩的加分。