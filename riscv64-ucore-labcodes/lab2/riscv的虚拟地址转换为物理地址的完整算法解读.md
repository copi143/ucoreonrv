### 地址格式
以sv39为例子，sv39意味着三级页表，有39=9+9+9+12位表示虚拟地址，sv48、sv57(好像目前riscv还不支持)其实就是页表级数(多一级，就多9位)增加。
>为什么是9？
>因为$2^9 \times 8B$=4KiB，恰好是一个页，也就是说，可以用一个页就能保存一个页表，访问页表的时候就不需要跨页
#### 虚拟地址格式
va.pgoff：0-11位
va.vpn[0]：12-20位
va.vpn[1]：21-29位
va.vpn[2]：30-38位
剩余的25位是第38位的副本

>为什么剩余的25位都不用？不是很浪费空间吗？
>答案是不需要这么多，sv39能为每一个程序模拟出512GiB($2^{39}$)的空间，目前来说已经够用了；当然，未来还会继续发展，可能512GiB就不够用了，可以用sv48、sv57，这时候有一个非常重要的问题——向后兼容。
>拓展更大的空间之后，以前的程序不能就这样无法运行了，因此这25位坚决不能用来作为其它用途(比如用来存数据)，只能让其留空。
#### 物理地址格式
pa.pgoff：0-11位
pa.ppn[0]：12-20位
pa.ppn[1]：21-29位
pa.ppn[2]：30-55位

>为什么物理页号一共是44位？多了少了都不行？
#### PET(页表项)格式
##### 63-54：10位保留位
暂时不使用
##### 53-10：一个物理页号
pte.ppn[0]：12-20位
pte.ppn[1]：21-29位
pte.ppn[2]：30-55位

##### 9-0：描述映射状态信息
1. 9-8：RSW：留给S Mode的应用程序
2. 7：D(Dirty)：如果D=1，表示有虚拟地址刚刚通过这个页表项进行写
3. 6：A(Accessed)：如果A=1，表示有虚拟地址刚刚通过这个项进行读或者写
4. 5：G(Global)：如果G=1，表示所有的页表(有多少张页表？为什么需要全局的页表？)都包含这一项
5. 4：U(User)：U=1为用户态，注意S态不能通过U=1的页面寻指令
6. 3：R(Readable)：可读
7. 2：W(Writable)：可写
8. 1：X(Executable)：可执行
9. 0：V：表示是否合法，为0表示不合法(即：没有对应物理页)，此时该项其他值会被忽视

>XWR(123位)组合：
>000：指向下一级页表的指针
>001：这一页只读
>010：不合法(R=0，W=1)
>011：这一页可读可写不可执行
>100：可读可执行
>101：可读可执行(?为什么重复?)
>110：不合法(R=0，W=1)
>111：可读可写可执行


#### stap格式
stap是一个crs寄存器，cpu访问内存的方式由这个寄存器决定
##### 63-60：MODE
表示cpu的访问模式，其取值和意义如下：
- 0000表示(Bare)不使用页表，直接使用物理地址，在简单的嵌入式系统里用着很方便。
- 1000表示sv39页表，也就是我们使用的，虚拟内存空间高达`512GiB`。
- 1001表示Sv48页表，它和Sv39兼容。
- 其他编码保留备用 ASID（address space identifier）我们目前用不到 OS 可以在内存中为不同的应用分别建立不同虚实映射的页表，并通过修改寄存器 satp 的值指向不同的页表，从而可以修改 CPU 虚实地址映射关系及内存保护的行为。

##### 59-44：ASID
可选，用来降低上下文切换的开销，这里可以先不管

##### 43-0：一个物理页号——对应一个页表
stap.ppn[0]：12-20位
stap.ppn[1]：21-29位
stap.ppn[2]：30-55位

### 算法解析
当然执行算法前，需要初始化satp以及pet
完整算法如下图所示：
![[riscv页面管理算法流程.png]]

根据之前关于地址格式的说明，sv39的三个级别的页的大小分别是4KiB、2MiB、1GiB，分别将其称为页、大页、大大页，可以大致总结出上述算法的流程：
1. 通过`stap`寄存器提供的物理页号找到第一个页表(大大页表)，根据虚拟地址的vpn[2]锁定目标pte
2. 通过pte的各种判断这个页表项的物理页号，是指向下一级页表，还是直接指向目标物理空间
3. 如果是指向下一级页表，根据vpn[1]寻找下一个pte，以此类推
4. 如果是指向目标物理空间，则：pa.ppn[i]=pte.ppn[i]，pa.ppn[i:0]=va.ppn[i:0]，pa.pgoff=va.pgoff















